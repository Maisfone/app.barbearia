import express from 'express'
import cors from 'cors'
import dotenv from 'dotenv'
import { randomUUID } from 'crypto'
import { z } from 'zod'
import { pool, withClient, initDb } from './db.js'

dotenv.config()

const app = express()
app.use(express.json())

// CORS config: suporta lista separada por vírgula ou '*'
function getCorsOrigin() {
  const raw = process.env.ALLOWED_ORIGIN
  if (!raw || raw === '*' || raw.trim() === '') return true
  const items = raw.split(',').map(s => s.trim()).filter(Boolean)
  return items.length === 1 ? items[0] : items
}
app.use(cors({ origin: getCorsOrigin() }))

// Service day boundary (default 5 AM local time)
function getServiceDate() {
  const h = Number(process.env.SHIFT_START_HOUR || 5)
  const now = new Date()
  const shifted = new Date(now.getTime() - h * 60 * 60 * 1000)
  // Return YYYY-MM-DD
  return shifted.toISOString().slice(0, 10)
}

// ----- SSE infrastructure -----
const shopCurrentStreams = new Map() // shopCode -> Set(res)
const shopListStreams = new Map()    // shopCode -> Set(res)
const shopSettingsStreams = new Map() // shopCode -> Set(res)

function sseAdd(streamsMap, key, res) {
  if (!streamsMap.has(key)) streamsMap.set(key, new Set())
  streamsMap.get(key).add(res)
}
function sseRemove(streamsMap, key, res) {
  const set = streamsMap.get(key)
  if (!set) return
  set.delete(res)
  if (set.size === 0) streamsMap.delete(key)
}
function sseSend(res, event, data) {
  res.write(`event: ${event}\n`)
  res.write(`data: ${JSON.stringify(data)}\n\n`)
}

async function computeCurrentNumber(shopCode) {
  const serviceDate = getServiceDate()
  const cur = await pool.query(
    `SELECT COALESCE(MAX(ticket_number), 0) AS current
       FROM queue_entries
      WHERE shop_code = $1 AND ticket_date = $2::date AND status IN ('called','served')`,
    [shopCode, serviceDate]
  )
  return Number(cur.rows[0]?.current || 0)
}

async function broadcastCurrent(shopCode) {
  const set = shopCurrentStreams.get(shopCode)
  if (!set || set.size === 0) return
  const currentNumber = await computeCurrentNumber(shopCode)
  for (const res of set) sseSend(res, 'current', { currentNumber })
}

async function broadcastList(shopCode) {
  const set = shopListStreams.get(shopCode)
  if (!set || set.size === 0) return
  const { rows } = await pool.query(
    `SELECT id, customer_name, service_type, created_at, ticket_number
       FROM queue_entries WHERE shop_code = $1 AND status = 'waiting'
       ORDER BY created_at ASC`,
    [shopCode]
  )
  for (const res of set) sseSend(res, 'list', rows)
}

async function getShopSettings(shopCode) {
  const r = await pool.query(
    `SELECT paused, pause_message FROM shop_settings WHERE shop_code = $1`,
    [shopCode]
  )
  if (r.rows.length === 0) return { paused: false, pause_message: null }
  return r.rows[0]
}

async function broadcastSettings(shopCode) {
  const set = shopSettingsStreams.get(shopCode)
  if (!set || set.size === 0) return
  const s = await getShopSettings(shopCode)
  for (const res of set) sseSend(res, 'settings', s)
}

// Simple admin auth via Bearer token
function checkAdmin(req, res, next) {
  const header = req.headers['authorization'] || ''
  const token = header.startsWith('Bearer ') ? header.slice(7) : null
  if (!process.env.ADMIN_TOKEN) {
    return res.status(500).json({ error: 'ADMIN_TOKEN não configurado' })
  }
  if (!token || token !== process.env.ADMIN_TOKEN) {
    return res.status(401).json({ error: 'Não autorizado' })
  }
  next()
}

// Healthcheck
app.get('/api/health', (req, res) => {
  res.json({ ok: true })
})

app.get('/api/health/db', async (req, res) => {
  try {
    const ping = await pool.query('SELECT 1 as ok')
    const table = await pool.query("SELECT to_regclass('public.queue_entries') as t")
    const counters = await pool.query("SELECT to_regclass('public.queue_counters') as t")
    const cols = await pool.query(`
      SELECT column_name FROM information_schema.columns
      WHERE table_schema = 'public' AND table_name = 'queue_entries'
    `)
    const hasTicketNumber = cols.rows.some(r => r.column_name === 'ticket_number')
    res.json({
      ok: true,
      db: ping.rows[0].ok === 1,
      hasQueueTable: !!table.rows[0].t,
      hasCountersTable: !!counters.rows[0].t,
      hasTicketNumber,
    })
  } catch (e) {
    console.error('DB health error:', e)
    res.status(500).json({ ok: false, error: e.message })
  }
})

// Join queue
app.post('/api/queue/join', async (req, res) => {
  const schema = z.object({
    shopCode: z.string().min(1),
    name: z.string().min(1),
    phone: z.string().optional(),
    serviceType: z.string().optional(),
  })
  const parsed = schema.safeParse(req.body)
  if (!parsed.success) {
    return res.status(400).json({ error: 'Dados inválidos', details: parsed.error.flatten() })
  }
  const { shopCode, name, phone, serviceType } = parsed.data
  const id = randomUUID()
  try {
    // Check pause
    const settings = await getShopSettings(shopCode)
    if (settings.paused) {
      return res.status(423).json({ error: settings.pause_message || 'Fila temporariamente pausada' })
    }
    const result = await withClient(async (client) => {
      await client.query('BEGIN')
      try {
        const serviceDate = getServiceDate()
        await client.query(
          `INSERT INTO queue_counters (shop_code, counter_date, last_number)
           VALUES ($1, $2::date, 0)
           ON CONFLICT (shop_code, counter_date) DO NOTHING`,
          [shopCode, serviceDate]
        )
        const upd = await client.query(
          `UPDATE queue_counters
             SET last_number = last_number + 1
           WHERE shop_code = $1 AND counter_date = $2::date
           RETURNING last_number`,
          [shopCode, serviceDate]
        )
        const nextNumber = upd.rows[0]?.last_number || 1
        if (nextNumber > 1000) {
          await client.query('ROLLBACK')
          return { full: true }
        }
        await client.query(
          `INSERT INTO queue_entries (id, shop_code, customer_name, phone, service_type, status, ticket_number, ticket_date)
           VALUES ($1, $2, $3, $4, $5, 'waiting', $6, $7::date)`,
          [id, shopCode, name, phone || null, serviceType || null, nextNumber, serviceDate]
        )
        await client.query('COMMIT')
        return { ticketNumber: nextNumber }
      } catch (err) {
        try { await client.query('ROLLBACK') } catch {}
        throw err
      }
    })
    if (result.full) return res.status(409).json({ error: 'Limite diário atingido (1000 senhas)' })
    res.status(201).json({ ticketId: id, ticketNumber: result.ticketNumber })
    // realtime: atualizar lista do painel
    broadcastList(shopCode).catch(() => {})
  } catch (e) {
    console.error('Join error:', { message: e.message, code: e.code, detail: e.detail })
    if (e.code === '42P01' || String(e.message || '').includes('queue_counters')) {
      try {
        await initDb()
        // tentar novamente uma vez
        const retry = await withClient(async (client) => {
          await client.query('BEGIN')
          try {
            const serviceDate = getServiceDate()
            await client.query(
              `INSERT INTO queue_counters (shop_code, counter_date, last_number)
               VALUES ($1, $2::date, 0)
               ON CONFLICT (shop_code, counter_date) DO NOTHING`,
              [shopCode, serviceDate]
            )
            const upd = await client.query(
              `UPDATE queue_counters
                 SET last_number = last_number + 1
               WHERE shop_code = $1 AND counter_date = $2::date
               RETURNING last_number`,
              [shopCode, serviceDate]
            )
            const nextNumber = upd.rows[0]?.last_number || 1
            if (nextNumber > 1000) {
              await client.query('ROLLBACK')
              return { full: true }
            }
            await client.query(
              `INSERT INTO queue_entries (id, shop_code, customer_name, phone, service_type, status, ticket_number, ticket_date)
               VALUES ($1, $2, $3, $4, $5, 'waiting', $6, $7::date)`,
              [id, shopCode, name, phone || null, serviceType || null, nextNumber, serviceDate]
            )
            await client.query('COMMIT')
            return { ticketNumber: nextNumber }
          } catch (err) {
            try { await client.query('ROLLBACK') } catch {}
            throw err
          }
        })
        if (retry.full) return res.status(409).json({ error: 'Limite diário atingido (1000 senhas)' })
        res.status(201).json({ ticketId: id, ticketNumber: retry.ticketNumber })
        broadcastList(shopCode).catch(() => {})
        return
      } catch (e2) {
        console.error('Join retry after initDb failed:', { message: e2.message, code: e2.code, detail: e2.detail })
      }
    }
    res.status(500).json({ error: 'Erro ao entrar na fila' })
  }
})

// Get position by ticket
app.get('/api/queue/position/:ticketId', async (req, res) => {
  const { ticketId } = req.params
  try {
    const { rows } = await pool.query('SELECT * FROM queue_entries WHERE id = $1', [ticketId])
    const entry = rows[0]
    if (!entry) return res.status(404).json({ error: 'Ticket não encontrado' })

    const waiting = await pool.query(
      `SELECT id, created_at FROM queue_entries
       WHERE shop_code = $1 AND status = 'waiting'
       ORDER BY created_at ASC`,
      [entry.shop_code]
    )
    const index = waiting.rows.findIndex(r => r.id === ticketId)
    const position = index === -1 ? null : index + 1

    // Estimativa simples: 15 min por cliente à frente
    const avgMinutes = 15
    const ahead = index === -1 ? 0 : index
    const estimate = index === -1 ? 0 : ahead * avgMinutes

    // Número atual sendo atendido no mesmo dia de serviço
    let currentNumber = 0
    if (entry.ticket_date) {
      const cur = await pool.query(
        `SELECT COALESCE(MAX(ticket_number), 0) AS current
           FROM queue_entries
          WHERE shop_code = $1 AND ticket_date = $2::date AND status IN ('called','served')`,
        [entry.shop_code, entry.ticket_date]
      )
      currentNumber = Number(cur.rows[0]?.current || 0)
    }

    res.json({
      status: entry.status,
      position,
      ahead,
      estimateMinutes: estimate,
      shopCode: entry.shop_code,
      ticketNumber: entry.ticket_number,
      ticketDate: entry.ticket_date,
      currentNumber,
    })
  } catch (e) {
    console.error(e)
    res.status(500).json({ error: 'Erro ao consultar posição' })
  }
})

// List waiting queue (admin/painel)
app.get('/api/queue/list', checkAdmin, async (req, res) => {
  const shopCode = req.query.shopCode
  if (!shopCode) return res.status(400).json({ error: 'shopCode é obrigatório' })
  try {
    const { rows } = await pool.query(
      `SELECT id, customer_name, service_type, created_at, ticket_number
       FROM queue_entries WHERE shop_code = $1 AND status = 'waiting'
       ORDER BY created_at ASC`,
      [shopCode]
    )
    res.json(rows)
  } catch (e) {
    console.error(e)
    res.status(500).json({ error: 'Erro ao listar fila' })
  }
})

// SSE: current number for a shop (public)
app.get('/api/queue/stream/current', async (req, res) => {
  const shopCode = req.query.shopCode
  if (!shopCode) return res.status(400).json({ error: 'shopCode é obrigatório' })
  res.setHeader('Content-Type', 'text/event-stream')
  res.setHeader('Cache-Control', 'no-cache')
  res.setHeader('Connection', 'keep-alive')
  res.flushHeaders?.()
  sseAdd(shopCurrentStreams, shopCode, res)
  // send initial
  computeCurrentNumber(shopCode).then((n) => sseSend(res, 'current', { currentNumber: n })).catch(() => {})
  req.on('close', () => sseRemove(shopCurrentStreams, shopCode, res))
})

// SSE: waiting list for a shop (admin via token query)
app.get('/api/queue/stream/list', async (req, res) => {
  const shopCode = req.query.shopCode
  const token = req.query.token
  if (!shopCode) return res.status(400).json({ error: 'shopCode é obrigatório' })
  if (!token || token !== process.env.ADMIN_TOKEN) return res.status(401).json({ error: 'Não autorizado' })
  res.setHeader('Content-Type', 'text/event-stream')
  res.setHeader('Cache-Control', 'no-cache')
  res.setHeader('Connection', 'keep-alive')
  res.flushHeaders?.()
  sseAdd(shopListStreams, shopCode, res)
  // initial snapshot
  pool.query(
    `SELECT id, customer_name, service_type, created_at, ticket_number
       FROM queue_entries WHERE shop_code = $1 AND status = 'waiting'
       ORDER BY created_at ASC`,
    [shopCode]
  ).then(({ rows }) => sseSend(res, 'list', rows)).catch(() => {})
  req.on('close', () => sseRemove(shopListStreams, shopCode, res))
})

// SSE: shop settings (pause/message) public
app.get('/api/queue/stream/settings', async (req, res) => {
  const shopCode = req.query.shopCode
  if (!shopCode) return res.status(400).json({ error: 'shopCode é obrigatório' })
  res.setHeader('Content-Type', 'text/event-stream')
  res.setHeader('Cache-Control', 'no-cache')
  res.setHeader('Connection', 'keep-alive')
  res.flushHeaders?.()
  sseAdd(shopSettingsStreams, shopCode, res)
  getShopSettings(shopCode).then((s) => sseSend(res, 'settings', s)).catch(() => {})
  req.on('close', () => sseRemove(shopSettingsStreams, shopCode, res))
})

// Services (public list)
app.get('/api/services', async (req, res) => {
  const shopCode = req.query.shopCode
  if (!shopCode) return res.status(400).json({ error: 'shopCode é obrigatório' })
  try {
    const { rows } = await pool.query(
      `SELECT id, name, duration_minutes FROM services WHERE shop_code = $1 AND active = TRUE ORDER BY name ASC`,
      [shopCode]
    )
    res.json(rows)
  } catch (e) {
    console.error(e)
    res.status(500).json({ error: 'Erro ao listar serviços' })
  }
})

// Services (admin create)
app.post('/api/services', checkAdmin, async (req, res) => {
  const schema = z.object({ shopCode: z.string().min(1), name: z.string().min(1), durationMinutes: z.number().int().positive().optional() })
  const parsed = schema.safeParse(req.body)
  if (!parsed.success) return res.status(400).json({ error: 'Dados inválidos' })
  const { shopCode, name, durationMinutes } = parsed.data
  const id = randomUUID()
  try {
    await pool.query(
      `INSERT INTO services (id, shop_code, name, duration_minutes, active) VALUES ($1, $2, $3, $4, TRUE)`,
      [id, shopCode, name, durationMinutes ?? null]
    )
    res.status(201).json({ id })
  } catch (e) {
    console.error(e)
    res.status(500).json({ error: 'Erro ao criar serviço' })
  }
})

// Services (admin delete/deactivate)
app.delete('/api/services/:id', checkAdmin, async (req, res) => {
  const { id } = req.params
  try {
    await pool.query(`UPDATE services SET active = FALSE WHERE id = $1`, [id])
    res.json({ ok: true })
  } catch (e) {
    console.error(e)
    res.status(500).json({ error: 'Erro ao remover serviço' })
  }
})

// Shop settings endpoints
app.get('/api/shop/settings', async (req, res) => {
  const shopCode = req.query.shopCode
  if (!shopCode) return res.status(400).json({ error: 'shopCode é obrigatório' })
  try {
    const s = await getShopSettings(shopCode)
    res.json(s)
  } catch (e) {
    console.error(e)
    res.status(500).json({ error: 'Erro ao buscar configurações' })
  }
})

app.post('/api/shop/settings', checkAdmin, async (req, res) => {
  const schema = z.object({ shopCode: z.string().min(1), paused: z.boolean(), pauseMessage: z.string().nullable().optional() })
  const parsed = schema.safeParse(req.body)
  if (!parsed.success) return res.status(400).json({ error: 'Dados inválidos' })
  const { shopCode, paused, pauseMessage } = parsed.data
  try {
    await pool.query(
      `INSERT INTO shop_settings (shop_code, paused, pause_message, updated_at)
       VALUES ($1, $2, $3, NOW())
       ON CONFLICT (shop_code)
       DO UPDATE SET paused = EXCLUDED.paused, pause_message = EXCLUDED.pause_message, updated_at = NOW()`,
      [shopCode, paused, pauseMessage ?? null]
    )
    res.json({ ok: true })
    broadcastSettings(shopCode).catch(() => {})
  } catch (e) {
    console.error(e)
    res.status(500).json({ error: 'Erro ao salvar configurações' })
  }
})

// Current called/served ticket number for today (admin)
app.get('/api/queue/current', checkAdmin, async (req, res) => {
  const shopCode = req.query.shopCode
  if (!shopCode) return res.status(400).json({ error: 'shopCode é obrigatório' })
  try {
    const serviceDate = getServiceDate()
    const cur = await pool.query(
      `SELECT COALESCE(MAX(ticket_number), 0) AS current
         FROM queue_entries
        WHERE shop_code = $1 AND ticket_date = $2::date AND status IN ('called','served')`,
      [shopCode, serviceDate]
    )
    res.json({ currentNumber: Number(cur.rows[0]?.current || 0), serviceDate })
  } catch (e) {
    console.error(e)
    res.status(500).json({ error: 'Erro ao consultar senha atual' })
  }
})

// Call next in queue (admin)
app.post('/api/queue/next', checkAdmin, async (req, res) => {
  const schema = z.object({ shopCode: z.string().min(1) })
  const parsed = schema.safeParse(req.body)
  if (!parsed.success) return res.status(400).json({ error: 'Dados inválidos' })
  const { shopCode } = parsed.data
  try {
    const rows = await withClient(async (client) => {
      await client.query('BEGIN')
      try {
        const next = await client.query(
          `SELECT id FROM queue_entries WHERE shop_code = $1 AND status = 'waiting'
           ORDER BY created_at ASC LIMIT 1 FOR UPDATE SKIP LOCKED`,
          [shopCode]
        )
        if (next.rows.length === 0) {
          await client.query('COMMIT')
          return []
        }
        const ticketId = next.rows[0].id
        await client.query(
          `UPDATE queue_entries SET status = 'called', called_at = NOW() WHERE id = $1`,
          [ticketId]
        )
        await client.query('COMMIT')
        const tn = await client.query('SELECT ticket_number FROM queue_entries WHERE id = $1', [ticketId])
        return [{ id: ticketId, ticket_number: tn.rows[0]?.ticket_number }]
      } catch (err) {
        try { await client.query('ROLLBACK') } catch {}
        throw err
      }
    })
    if (rows.length === 0) return res.json({ message: 'Fila vazia' })
    res.json({ ticketId: rows[0].id, ticketNumber: rows[0].ticket_number })
    // realtime: atualizar namero atual e lista
    broadcastCurrent(shopCode).catch(() => {})
    broadcastList(shopCode).catch(() => {})
  } catch (e) {
    console.error(e)
    res.status(500).json({ error: 'Erro ao chamar próximo' })
  }
})

// Complete or cancel ticket
app.post('/api/queue/:ticketId/complete', checkAdmin, async (req, res) => {
  const { ticketId } = req.params
  try {
    const r = await pool.query('UPDATE queue_entries SET status = \'served\', served_at = NOW() WHERE id = $1 RETURNING shop_code', [ticketId])
    res.json({ ok: true })
    const shopCode = r.rows[0]?.shop_code
    if (shopCode) broadcastList(shopCode).catch(() => {})
  } catch (e) {
    console.error(e)
    res.status(500).json({ error: 'Erro ao concluir atendimento' })
  }
})

app.post('/api/queue/:ticketId/cancel', checkAdmin, async (req, res) => {
  const { ticketId } = req.params
  try {
    const r = await pool.query("UPDATE queue_entries SET status = 'canceled' WHERE id = $1 RETURNING shop_code", [ticketId])
    res.json({ ok: true })
    const shopCode = r.rows[0]?.shop_code
    if (shopCode) broadcastList(shopCode).catch(() => {})
  } catch (e) {
    console.error(e)
    res.status(500).json({ error: 'Erro ao cancelar' })
  }
})

// Allow customer to cancel own ticket (leave the queue)
app.post('/api/queue/:ticketId/leave', async (req, res) => {
  const { ticketId } = req.params
  try {
    const r = await pool.query(
      "UPDATE queue_entries SET status = 'canceled' WHERE id = $1 AND status IN ('waiting','called') RETURNING shop_code, status",
      [ticketId]
    )
    if (r.rowCount === 0) return res.status(409).json({ error: 'Não é possível cancelar este ticket' })
    const shopCode = r.rows[0]?.shop_code
    if (shopCode) broadcastList(shopCode).catch(() => {})
    res.json({ ok: true })
  } catch (e) {
    console.error(e)
    res.status(500).json({ error: 'Erro ao desistir da fila' })
  }
})

const port = Number(process.env.PORT || 4000)
async function start() {
  try {
    await initDb()
    console.log('DB schema verificado')
  } catch (e) {
    console.error('Falha ao inicializar DB:', e)
  }
  app.listen(port, () => {
    console.log(`Barbearia API rodando em http://localhost:${port}`)
  })
}

start()

